#!/usr/bin/env python2
# -*- coding:utf-8; mode:python -*-
# ॐ तारे तुत्तारे तुरे स्व
"""
HLS Prober for 451 Fahrenheit mediaserver.
Author: Alexander I.Grafov (Axel) <grafov@gmail.com>
This utility licensed under GPL v3.

Uses https://pypi.python.org/pypi/m3u8 for M3U8 playlists parsing.
Scripted in Python2 because m3u8 lib still don't work under Python3.
"""
__version__ = "0.1"

import sys
import os
import random
import time
import signal
import logging
import urllib2
import smtplib
import m3u8
import yaml
from email.mime.text import MIMEText
from multiprocessing import Process, Queue
from subprocess import check_output, call, Popen, PIPE

CONFIG = "~/.hlsproberc"


class CupertinoProbe:
    """ Parse variant and stream M3U8-playlists. Parser uses python `m3u8` library.
    Get playlist URLs from the task queue.
    """
    def __init__(self, playlistq, chunkq, bugq, pno, log):
        self.playlistq = playlistq
        self.chunkq = chunkq
        self.bugq = bugq
        self.pno = pno
        self.log = log

    def __call__(self):
        """ Read and parse a playlist."""
        while True:
            try:
                uri = self.playlistq.get(True)
                playlist = m3u8.load(uri)
                self.log.debug("Load playlist from %s" % uri)
                if playlist.is_variant:
                    # Load stream playlists and put them back to playlist queue
                    for stream in playlist.playlists:
                        while self.playlistq.full():
                            self.log.debug("Playlist queue is full.")
                            time.sleep(3)
                        self.playlistq.put("%s/%s" % (stream.baseuri, stream.uri))
                    else:
                        self.bugq.put({"list-empty": "%s/%s" % (stream.baseuri, stream.uri)})
                else:
                    # Load URLs to media chunks and put them to chunk queue
                    for seg in playlist.segments:
                        while self.chunkq.full():
                            self.log.debug("Chunk queue is full.")
                            time.sleep(3)
                        self.chunkq.put("%s/%s" % (playlist.baseuri, seg.uri))
            except KeyboardInterrupt:
                self.log.info("Finalize cupertino prober %s." % self.pno)
            except:
                self.log.warn("Failed to open %s stream" % uri)
                self.bugq.put({"no-stream": uri})
                continue


class MediaProbe:
    """ Get and analyze media chunks.
    """
    def __init__(self, chunkq, bugq, log):
        self.chunkq = chunkq
        self.bugq = bugq
        self.log = log
        self.loaded = [] # cache list of already loaded chunks

    def __call__(self):
        while True:
            try:
                uri = self.chunkq.get(True)
                if uri in self.loaded:
                    self.log.debug("Chunk %s already loaded." % uri)
                    continue
                resp = urllib2.urlopen(uri, timeout=6)
                data = resp.read()
                self.log.debug("Probed chunk %s (len %d)" % (uri, len(data)))
                if len(self.loaded) > 96:
                    self.loaded = self.loaded[32:]
            except IOError:
                self.log.error("Error on read %s" % uri)
            except KeyboardInterrupt:
                self.log.info("Finalize media prober.")

    def analyze(self):
        """ TODO Analyze with Mediainfo.
        """
        pass

class Source:
    """ Reads config data and puts urls to task queue.
    """
    def __init__(self, playlistq, log):
        """ На входе файл конфига `confile` и очередь задач `playlistq`.
        """
        self.playlistq = playlistq
        self.log = log
        try:
            self.streams = [x if not x.startswith('#') else '' for x in open(os.path.expanduser(CONFIG)).read().strip().split('\n')]
        except IOError:
            self.log.fatal("Can't open config file. Exit.")
            exit(1)

    def __call__(self):
        """ Read the channel list and put tasks to playlist queue.
        """
        while True:
            try:
                if self.playlistq.full():
                    self.log.debug("Playlist queue is full.")
                    time.sleep(3)
                    continue
                self.playlistq.put(random.choice(self.streams))
                time.sleep(12)
            except KeyboardInterrupt:
                self.log.info("Exit source parser.")


class ProblemAnalyzer:
    def __init__(self, bugq, log):
        """ Gather and analyze problems with streams. Log it or send mail on critical incidents.
        """
        self.bugq = bugq
        self.log = log

    def __call__(self):
        while True:
            try:
                err = self.bugq.get(True)
            except KeyboardInterrupt:
                self.log.info("Exit problem analyzer.")


class Notify:
    """ Send emails if problems detected.
    """
    def __init__(self, mailcf):
        self.subject = mailcf.subject
        self.author = mailcf.author
        self.to = mailcf.adresses

    def send(self, text):
        msg = MIMEText(text)
        msg['Subject'] = os.path.expandvars(self.subject)
        msg['From'] = self.author
        msg['To'] = self.to
        mail = smtplib.SMTP("localhost")
        mail.sendmail(self.author, [self.to.split(';')], msg.as_string())
        mail.quit()


class Config:
    def __init__(self):
        try:
            self.cfg = yaml.load(open(os.path.expanduser(CONFIG)).read().strip().split('\n'))
        except:
            exit(1)

    def __call__(self):
        return self.cfg


class FlowController:
    """ Manage all probe-tasks over workers.
    """
    def __init__(self, log):
        self.log = log
        playlistq = Queue(32)
        chunkq = Queue(96)
        bugq = Queue(16)
        self.slots = []
        for i in range(3):
            self.slots.append(Process(target=CupertinoProbe(playlistq, chunkq, bugq, i, self.log)))
        self.slots.append(Process(target=MediaProbe(chunkq, bugq, self.log)))
        self.slots.append(Process(target=Source(playlistq, self.log)))
        self.slots.append(Process(target=ProblemAnalyzer(bugq, self.log)))

    def run(self):
        for slot in self.slots:
            slot.start()
        try:
            signal.pause()
        except KeyboardInterrupt:
            for slot in self.slots:
                self.log.info("Exit subprocess %s" % slot.pid)
                slot.terminate()
            self.log.info("Control process %s interrupted by operator." % os.getpid())


def init_log():
    """ Customizable logging to STDERR.
    """
    log = logging.getLogger("hlsprobe")
    hdlr = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    hdlr.setFormatter(formatter)
    log.addHandler(hdlr)
    log.setLevel(logging.DEBUG)
    return log


def main():
    """ Workflow:
    Source -[playlist url]-> TaskQueue ->>> CupertinoProbe -[chunk url]-> TaskQueue -> MediaProbe [bool]
    """
    log = init_log()
    log.info("HLS Probe v%s started" % __version__)
    flowc = FlowController(log)
    flowc.run()


if __name__ == "__main__":
    main()
